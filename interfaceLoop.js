var centresTexture3 = [
  [10, 61],
  [27, 392],
  [27, 440],
  [34, 286],
  [38, 74],
  [39, 75],
  [96, 348],
  [153, 123],
  [153, 500],
  [176, 268],
  [216, 45],
  [257, 368],
  [272, 133],
  [302, 210],
  [318, 121],
  [338, 11],
  [341, 294],
  [360, 159],
  [372, 425],
  [389, 258],
  [409, 226],
  [441, 324],
  [445, 443],
  [448, 49],
  [475, 142],
  [477, 410],
  [496, 469],
  [505, 7],
];
var centresTexture5 = [
  [4, 61],
  [4, 79],
  [7, 302],
  [8, 413],
  [10, 198],
  [11, 20],
  [13, 120],
  [28, 249],
  [33, 477],
  [37, 61],
  [39, 162],
  [49, 406],
  [63, 15],
  [66, 37],
  [68, 256],
  [71, 184],
  [78, 6],
  [84, 345],
  [86, 394],
  [87, 94],
  [88, 291],
  [89, 135],
  [91, 413],
  [104, 222],
  [104, 403],
  [110, 289],
  [112, 467],
  [115, 409],
  [124, 26],
  [128, 423],
  [132, 398],
  [133, 304],
  [134, 258],
  [139, 417],
  [142, 78],
  [143, 385],
  [146, 152],
  [147, 220],
  [151, 410],
  [155, 310],
  [155, 505],
  [158, 386],
  [161, 399],
  [166, 293],
  [177, 385],
  [179, 321],
  [180, 250],
  [181, 215],
  [189, 7],
  [192, 77],
  [198, 107],
  [199, 192],
  [199, 394],
  [205, 347],
  [205, 378],
  [206, 125],
  [212, 155],
  [215, 60],
  [216, 7],
  [217, 209],
  [221, 39],
  [224, 386],
  [224, 445],
  [234, 362],
  [237, 382],
  [244, 173],
  [248, 283],
  [249, 374],
  [259, 198],
  [259, 383],
  [274, 4],
  [275, 100],
  [282, 481],
  [287, 372],
  [296, 179],
  [302, 212],
  [308, 386],
  [309, 357],
  [311, 377],
  [313, 493],
  [314, 400],
  [317, 253],
  [317, 369],
  [318, 401],
  [319, 410],
  [323, 273],
  [323, 335],
  [324, 386],
  [326, 33],
  [327, 168],
  [327, 370],
  [330, 314],
  [331, 434],
  [332, 405],
  [335, 13],
  [336, 372],
  [338, 345],
  [339, 293],
  [343, 327],
  [344, 57],
  [346, 453],
  [353, 317],
  [354, 239],
  [355, 157],
  [363, 85],
  [364, 112],
  [376, 329],
  [384, 476],
  [386, 174],
  [387, 100],
  [388, 393],
  [390, 233],
  [392, 204],
  [399, 140],
  [405, 251],
  [407, 313],
  [408, 112],
  [411, 447],
  [412, 279],
  [413, 171],
  [420, 21],
  [434, 431],
  [437, 111],
  [443, 463],
  [444, 135],
  [456, 377],
  [461, 119],
  [463, 413],
  [468, 95],
  [475, 486],
  [486, 82],
  [490, 503],
  [492, 320],
  [497, 379],
  [499, 206],
  [500, 468],
  [501, 414],
  [502, 8],
  [502, 114],
];
var centresTexture6 = [
  [4, 70],
  [12, 229],
  [38, 33],
  [40, 401],
  [61, 313],
  [78, 119],
  [81, 462],
  [84, 173],
  [96, 236],
  [114, 59],
  [118, 361],
  [143, 182],
  [152, 133],
  [171, 418],
  [173, 503],
  [185, 271],
  [188, 203],
  [196, 78],
  [203, 150],
  [209, 348],
  [235, 124],
  [244, 429],
  [247, 174],
  [251, 34],
  [255, 237],
  [281, 297],
  [282, 355],
  [291, 493],
  [297, 187],
  [302, 406],
  [312, 116],
  [326, 38],
  [331, 449],
  [335, 353],
  [342, 239],
  [360, 295],
  [367, 504],
  [370, 403],
  [374, 167],
  [378, 340],
  [399, 462],
  [410, 116],
  [416, 368],
  [420, 49],
  [436, 281],
  [438, 328],
  [439, 411],
  [440, 152],
  [447, 215],
  [462, 92],
  [481, 499],
  [493, 364],
  [500, 436],
  [505, 297],
  [508, 136],
];
var centresTexture7 = [
  [5, 113],
  [8, 147],
  [9, 411],
  [10, 30],
  [11, 358],
  [14, 307],
  [18, 218],
  [18, 497],
  [19, 426],
  [20, 97],
  [22, 440],
  [22, 462],
  [24, 5],
  [28, 364],
  [39, 270],
  [40, 130],
  [45, 177],
  [45, 428],
  [47, 393],
  [55, 55],
  [58, 312],
  [67, 476],
  [68, 5],
  [72, 209],
  [73, 373],
  [78, 341],
  [79, 113],
  [80, 95],
  [82, 413],
  [90, 67],
  [90, 81],
  [93, 161],
  [95, 9],
  [96, 115],
  [96, 257],
  [104, 64],
  [111, 432],
  [112, 309],
  [120, 485],
  [123, 199],
  [124, 386],
  [127, 143],
  [133, 163],
  [135, 21],
  [141, 132],
  [149, 147],
  [150, 502],
  [161, 454],
  [165, 245],
  [166, 101],
  [168, 365],
  [169, 35],
  [169, 424],
  [174, 408],
  [175, 310],
  [179, 391],
  [182, 51],
  [190, 198],
  [201, 346],
  [203, 368],
  [209, 12],
  [214, 144],
  [219, 59],
  [220, 502],
  [224, 130],
  [228, 28],
  [229, 158],
  [232, 91],
  [235, 423],
  [238, 472],
  [239, 369],
  [243, 72],
  [244, 114],
  [247, 211],
  [257, 8],
  [261, 510],
  [262, 255],
  [272, 95],
  [276, 165],
  [281, 377],
  [286, 289],
  [288, 333],
  [294, 384],
  [295, 478],
  [296, 38],
  [296, 115],
  [297, 219],
  [298, 289],
  [299, 437],
  [305, 379],
  [311, 226],
  [320, 507],
  [321, 1],
  [328, 492],
  [330, 164],
  [337, 308],
  [347, 115],
  [350, 23],
  [350, 74],
  [351, 328],
  [356, 402],
  [357, 40],
  [364, 461],
  [365, 228],
  [379, 494],
  [380, 9],
  [386, 147],
  [387, 51],
  [400, 457],
  [406, 280],
  [407, 26],
  [409, 335],
  [410, 265],
  [417, 384],
  [418, 468],
  [425, 67],
  [426, 172],
  [428, 288],
  [428, 481],
  [438, 203],
  [441, 186],
  [443, 300],
  [451, 176],
  [454, 112],
  [456, 485],
  [459, 507],
  [460, 20],
  [462, 295],
  [463, 361],
  [465, 426],
  [479, 486],
  [485, 371],
  [486, 220],
  [491, 323],
  [498, 366],
  [499, 54],
  [505, 488],
  [506, 144],
  [508, 5],
  [508, 119],
  [508, 359],
  [509, 377],
  [510, 22],
];
var centresTexture8 = [
  [17, 260],
  [30, 459],
  [36, 357],
  [47, 48],
  [58, 146],
  [70, 308],
  [83, 329],
  [95, 504],
  [98, 239],
  [105, 317],
  [121, 415],
  [151, 126],
  [159, 186],
  [166, 46],
  [167, 508],
  [178, 293],
  [198, 478],
  [208, 217],
  [230, 78],
  [241, 155],
  [277, 360],
  [278, 64],
  [279, 478],
  [285, 254],
  [288, 11],
  [368, 155],
  [389, 38],
  [392, 305],
  [392, 440],
  [460, 327],
  [463, 179],
  [476, 498],
  [477, 431],
  [480, 8],
  [480, 57],
  [483, 369],
  [493, 250],
  [499, 142],
  [505, 439],
  [506, 387],
  [509, 85],
];
var centresTexture10 = [
  [3, 312],
  [3, 313],
  [4, 419],
  [5, 281],
  [6, 194],
  [8, 137],
  [8, 371],
  [8, 403],
  [9, 223],
  [9, 251],
  [10, 36],
  [13, 165],
  [16, 316],
  [20, 239],
  [22, 406],
  [23, 9],
  [23, 105],
  [24, 72],
  [26, 143],
  [26, 368],
  [28, 475],
  [29, 495],
  [32, 443],
  [34, 43],
  [34, 477],
  [38, 129],
  [40, 397],
  [41, 97],
  [42, 200],
  [42, 335],
  [43, 171],
  [43, 264],
  [47, 38],
  [49, 476],
  [52, 55],
  [52, 478],
  [55, 75],
  [57, 151],
  [59, 100],
  [59, 472],
  [61, 371],
  [62, 166],
  [68, 229],
  [68, 300],
  [68, 424],
  [72, 54],
  [76, 22],
  [76, 130],
  [83, 158],
  [83, 181],
  [85, 396],
  [87, 101],
  [91, 497],
  [92, 138],
  [93, 447],
  [97, 69],
  [97, 120],
  [98, 344],
  [99, 148],
  [100, 398],
  [102, 207],
  [103, 6],
  [103, 41],
  [104, 171],
  [111, 290],
  [111, 326],
  [114, 166],
  [116, 131],
  [117, 79],
  [118, 358],
  [119, 432],
  [120, 258],
  [121, 159],
  [122, 140],
  [124, 119],
  [125, 100],
  [125, 405],
  [127, 18],
  [130, 505],
  [131, 315],
  [137, 162],
  [137, 224],
  [137, 342],
  [137, 457],
  [143, 275],
  [145, 67],
  [152, 34],
  [152, 178],
  [152, 319],
  [153, 212],
  [155, 434],
  [160, 6],
  [160, 263],
  [164, 54],
  [168, 226],
  [169, 381],
  [171, 115],
  [178, 196],
  [182, 476],
  [183, 28],
  [183, 193],
  [186, 172],
  [186, 214],
  [187, 48],
  [189, 325],
  [190, 68],
  [190, 492],
  [191, 233],
  [191, 288],
  [198, 356],
  [199, 203],
  [204, 476],
  [207, 143],
  [210, 312],
  [210, 321],
  [211, 435],
  [216, 5],
  [217, 327],
  [218, 262],
  [220, 125],
  [221, 214],
  [222, 461],
  [223, 39],
  [226, 303],
  [227, 398],
  [228, 89],
  [235, 330],
  [241, 230],
  [243, 111],
  [243, 477],
  [245, 164],
  [249, 503],
  [253, 266],
  [256, 27],
  [258, 450],
  [261, 65],
  [261, 98],
  [267, 355],
  [269, 191],
  [269, 300],
  [282, 468],
  [284, 137],
  [284, 442],
  [285, 103],
  [287, 9],
  [287, 272],
  [296, 72],
  [298, 378],
  [299, 42],
  [299, 180],
  [299, 230],
  [303, 114],
  [304, 24],
  [306, 147],
  [308, 107],
  [309, 266],
  [311, 109],
  [312, 407],
  [315, 197],
  [317, 59],
  [317, 100],
  [317, 491],
  [320, 329],
  [322, 473],
  [323, 93],
  [324, 354],
  [325, 354],
  [326, 354],
  [327, 13],
  [327, 295],
  [331, 36],
  [331, 229],
  [335, 83],
  [335, 161],
  [337, 394],
  [339, 474],
  [340, 131],
  [341, 95],
  [342, 445],
  [343, 76],
  [343, 352],
  [347, 45],
  [348, 9],
  [350, 244],
  [351, 485],
  [353, 64],
  [353, 435],
  [355, 76],
  [358, 198],
  [361, 13],
  [364, 284],
  [364, 469],
  [367, 68],
  [370, 117],
  [372, 62],
  [377, 409],
  [378, 247],
  [379, 92],
  [383, 303],
  [386, 16],
  [389, 499],
  [392, 68],
  [392, 160],
  [394, 474],
  [396, 437],
  [402, 96],
  [402, 266],
  [405, 429],
  [408, 358],
  [410, 80],
  [411, 295],
  [412, 210],
  [416, 23],
  [416, 57],
  [417, 245],
  [422, 117],
  [425, 325],
  [428, 447],
  [430, 494],
  [432, 181],
  [432, 411],
  [434, 27],
  [435, 7],
  [437, 151],
  [437, 275],
  [443, 43],
  [443, 474],
  [444, 343],
  [445, 73],
  [445, 346],
  [447, 103],
  [449, 339],
  [450, 323],
  [454, 10],
  [457, 53],
  [457, 204],
  [457, 237],
  [457, 389],
  [458, 333],
  [459, 118],
  [460, 477],
  [463, 74],
  [463, 500],
  [464, 138],
  [466, 27],
  [467, 349],
  [469, 271],
  [472, 296],
  [474, 168],
  [476, 41],
  [482, 90],
  [482, 118],
  [483, 197],
  [484, 425],
  [486, 369],
  [490, 222],
  [491, 37],
  [494, 459],
  [496, 9],
  [496, 331],
  [497, 500],
  [499, 168],
  [500, 79],
  [501, 402],
  [502, 421],
  [503, 109],
  [504, 250],
  [504, 279],
  [504, 302],
  [505, 47],
  [505, 233],
  [506, 203],
  [507, 234],
];
var centresTexture11 = [
  [14, 33],
  [14, 306],
  [18, 393],
  [21, 218],
  [32, 480],
  [36, 81],
  [53, 255],
  [54, 147],
  [65, 391],
  [67, 216],
  [69, 36],
  [78, 97],
  [80, 352],
  [91, 299],
  [98, 430],
  [111, 504],
  [117, 386],
  [124, 103],
  [124, 341],
  [125, 232],
  [127, 147],
  [160, 441],
  [168, 319],
  [178, 44],
  [180, 267],
  [182, 138],
  [193, 385],
  [209, 476],
  [215, 187],
  [217, 227],
  [227, 285],
  [235, 120],
  [249, 336],
  [254, 69],
  [262, 436],
  [265, 2],
  [277, 301],
  [278, 113],
  [290, 177],
  [295, 262],
  [304, 398],
  [309, 344],
  [312, 293],
  [335, 459],
  [348, 388],
  [359, 14],
  [363, 174],
  [364, 93],
  [392, 246],
  [395, 314],
  [399, 7],
  [408, 180],
  [418, 379],
  [427, 476],
  [433, 142],
  [451, 507],
  [453, 327],
  [464, 59],
  [478, 178],
  [482, 131],
  [497, 441],
  [498, 6],
  [503, 508],
];
var centresTexture12 = [
  [5, 113],
  [8, 147],
  [9, 411],
  [10, 30],
  [11, 358],
  [14, 307],
  [18, 218],
  [18, 497],
  [19, 426],
  [20, 97],
  [22, 440],
  [22, 462],
  [24, 5],
  [28, 364],
  [39, 270],
  [40, 130],
  [45, 177],
  [45, 428],
  [47, 393],
  [55, 55],
  [58, 312],
  [67, 476],
  [68, 5],
  [72, 209],
  [73, 373],
  [78, 341],
  [79, 113],
  [80, 95],
  [82, 413],
  [90, 67],
  [90, 81],
  [93, 161],
  [95, 9],
  [96, 115],
  [96, 257],
  [104, 64],
  [111, 432],
  [112, 309],
  [120, 485],
  [123, 199],
  [124, 386],
  [127, 143],
  [133, 163],
  [135, 21],
  [141, 132],
  [149, 147],
  [150, 502],
  [161, 454],
  [165, 245],
  [166, 101],
  [168, 365],
  [169, 35],
  [169, 424],
  [174, 408],
  [175, 310],
  [179, 391],
  [182, 51],
  [190, 198],
  [201, 346],
  [203, 368],
  [209, 12],
  [214, 144],
  [219, 59],
  [220, 502],
  [224, 130],
  [228, 28],
  [229, 158],
  [232, 91],
  [235, 423],
  [238, 472],
  [239, 369],
  [243, 72],
  [244, 114],
  [247, 211],
  [257, 8],
  [261, 510],
  [262, 255],
  [272, 95],
  [276, 165],
  [281, 377],
  [286, 289],
  [288, 333],
  [294, 384],
  [295, 478],
  [296, 38],
  [296, 115],
  [297, 219],
  [298, 289],
  [299, 437],
  [305, 379],
  [311, 226],
  [320, 507],
  [321, 1],
  [328, 492],
  [330, 164],
  [337, 308],
  [347, 115],
  [350, 23],
  [350, 74],
  [351, 328],
  [356, 402],
  [357, 40],
  [364, 461],
  [365, 228],
  [379, 494],
  [380, 9],
  [386, 147],
  [387, 51],
  [400, 457],
  [406, 280],
  [407, 26],
  [409, 335],
  [410, 265],
  [417, 384],
  [418, 468],
  [425, 67],
  [426, 172],
  [428, 288],
  [428, 481],
  [438, 203],
  [441, 186],
  [443, 300],
  [451, 176],
  [454, 112],
  [456, 485],
  [459, 507],
  [460, 20],
  [462, 295],
  [463, 361],
  [465, 426],
  [479, 486],
  [485, 371],
  [486, 220],
  [491, 323],
  [498, 366],
  [499, 54],
  [505, 488],
  [506, 144],
  [508, 5],
  [508, 119],
  [508, 359],
  [509, 377],
  [510, 22],
];

var centresTexturePave = [
  [6, 7],
  [10, 63],
  [16, 230],
  [17, 144],
  [23, 318],
  [27, 407],
  [37, 496],
  [66, 19],
  [80, 92],
  [86, 174],
  [88, 256],
  [107, 347],
  [117, 437],
  [127, 507],
  [127, 510],
  [149, 40],
  [161, 118],
  [168, 199],
  [181, 286],
  [190, 374],
  [211, 471],
  [216, 5],
  [231, 63],
  [241, 147],
  [255, 227],
  [269, 315],
  [283, 402],
  [297, 16],
  [302, 493],
  [308, 93],
  [323, 171],
  [342, 257],
  [353, 344],
  [369, 436],
  [381, 39],
  [390, 511],
  [393, 117],
  [410, 198],
  [427, 285],
  [445, 6],
  [445, 371],
  [465, 464],
  [478, 139],
  [490, 227],
  [499, 313],
  [504, 21],
  [505, 400],
  [507, 95],
];

var centresTexturePaveJoint = [
  [21, 148],
  [24, 191],
  [24, 433],
  [25, 57],
  [25, 231],
  [25, 287],
  [25, 335],
  [25, 377],
  [25, 506],
  [26, 471],
  [28, 102],
  [29, 16],
  [84, 5],
  [86, 221],
  [87, 273],
  [87, 403],
  [87, 495],
  [88, 354],
  [89, 118],
  [89, 170],
  [90, 40],
  [90, 451],
  [91, 82],
  [92, 311],
  [156, 23],
  [158, 70],
  [158, 117],
  [158, 210],
  [160, 157],
  [160, 395],
  [160, 443],
  [161, 348],
  [161, 487],
  [162, 260],
  [165, 300],
  [222, 189],
  [222, 320],
  [223, 6],
  [225, 135],
  [225, 242],
  [225, 467],
  [225, 501],
  [226, 89],
  [227, 44],
  [227, 282],
  [227, 374],
  [228, 415],
  [264, 463],
  [266, 7],
  [266, 230],
  [266, 422],
  [267, 137],
  [267, 188],
  [267, 270],
  [268, 44],
  [268, 324],
  [268, 371],
  [268, 501],
  [270, 88],
  [314, 243],
  [315, 197],
  [316, 13],
  [316, 509],
  [317, 284],
  [318, 152],
  [318, 330],
  [318, 380],
  [318, 429],
  [318, 474],
  [319, 58],
  [320, 102],
  [387, 85],
  [387, 186],
  [389, 249],
  [389, 306],
  [390, 30],
  [390, 354],
  [390, 400],
  [390, 446],
  [390, 492],
  [392, 141],
  [452, 7],
  [454, 94],
  [456, 367],
  [457, 415],
  [458, 202],
  [459, 159],
  [459, 463],
  [460, 42],
  [460, 259],
  [460, 321],
  [461, 500],
  [501, 230],
  [502, 16],
  [503, 105],
  [503, 191],
  [503, 423],
  [503, 472],
  [504, 286],
  [504, 331],
  [505, 377],
  [506, 58],
  [506, 145],
];

init_textures();
init();
animate();

// Fonction pour définir un maillage de plan
function definePlane(mater, x, y, z, w, h, faces = 1) {
  geometryplane = meshPlane = new THREE.Mesh(
    new THREE.PlaneGeometry(w, h, faces, faces),
    mater
  );

  meshPlane.rotation.x += (-1 * Math.PI) / 2;
  meshPlane.position.x = x;
  meshPlane.position.y = y;
  meshPlane.position.z = z;

  return meshPlane;
}

// Fonction pour définir une texture
function defineTexture(src, repeatX, repeatY, repeatWrapping = false) {
  textu = new THREE.TextureLoader().load(src);
  if (repeatWrapping) {
    textu.wrapS = THREE.RepeatWrapping;
    textu.wrapT = THREE.RepeatWrapping;
    textu.repeat.set(repeatX, repeatY);
  } else {
    textu.wrapS = THREE.ClampToEdgeWrapping;
    textu.wrapT = THREE.ClampToEdgeWrapping;
  }

  return textu;
}

function defineTextureCanvas(src, repeatX, repeatY, repeatWrapping = false) {
  textu = new THREE.CanvasTexture(src);
  if (repeatWrapping) {
    textu.wrapS = THREE.RepeatWrapping;
    textu.wrapT = THREE.RepeatWrapping;
    textu.repeat.set(repeatX, repeatY);
  } else {
    textu.wrapS = THREE.ClampToEdgeWrapping;
    textu.wrapT = THREE.ClampToEdgeWrapping;
  }

  return textu;
}

function createCanvasforTextureRepeat(src, repeatX, repeatY) {
  // Get a reference to the image you want the pixels of and its dimensions
  var myImage1 = document.getElementById(src);

  var w1 = myImage1.width,
    h1 = myImage1.height;

  // Create a Canvas element
  var canvas1 = document.createElement("canvas");

  // Size the canvas to the element
  canvas1.width = w1 * repeatX;
  canvas1.height = h1 * repeatY;

  // Draw image onto the canvas
  var ctx1 = canvas1.getContext("2d");

  for (let i = 0; i < repeatX; i++) {
    for (let j = 0; j < repeatY; j++) {
      ctx1.drawImage(myImage1, w1 * i, j * h1);
    }
  }

  return canvas1;
}

function createTextureHerbe(repeatX, repeatY) {
  //console.log(herbe2);
  //console.log(herbe2)

  var wtot = herbetext.width,
    htot = herbetext.height;

  var w1 = wtot / 2;
  var h1 = htot / 4;
  console.log(w1);
  console.log(h1);

  // Create a Canvas element
  var canvasherbe = document.createElement("canvas");

  // Size the canvas to the element
  canvasherbe.width = w1 * repeatX;
  canvasherbe.height = h1 * repeatY;

  console.log(canvasherbe.width);

  //console.log(canvasherbe.height)

  // Draw image onto the canvas
  var ctx1 = canvasherbe.getContext("2d");

  herbetext.onload = FaireCanvasHerbe(repeatX, repeatY, ctx1, w1, h1);

  fleurtext = document.getElementById("fleur");
  margueritetext = document.getElementById("marguerite");

  wf = fleurtext.width;
  hf = fleurtext.height;

  wm = margueritetext.width;
  hm = margueritetext.height;

  fleurtext.onload = FaireFleurs(20, 1);
  margueritetext.onload = FaireFleurs(20, 2);

  //var im = ctxherbe.getImageData(0,0,w1*repeatX, h1*repeatY)
  //console.log(im.data)

  function FaireCanvasHerbe(repeatX, repeatY, ctxherbe, w1, h1) {
    for (let i = 0; i < repeatX; i++) {
      for (let j = 0; j < repeatY; j++) {
        var wr = Math.floor(Math.random() * 2);
        var hr = Math.floor(Math.random() * 4);

        ctx1.drawImage(
          herbetext,
          w1 * wr,
          h1 * hr,
          w1,
          h1,
          w1 * i,
          j * h1,
          w1,
          w1
        );
      }
    }
  }

  function FaireFleurs(nbFleur, numFleur) {
    for (let i = 0; i < nbFleur; i++) {
      var x = Math.floor(Math.random() * w1 * repeatX);
      var y = Math.floor(Math.random() * h1 * repeatY);

      var max = 3;
      var min = 5;

      var size = Math.random() * (max - min) + min;

      if (numFleur == 1) {
        ctx1.drawImage(fleurtext, 0, 0, wf, hf, x, y, wf / size, hf / size);
      } else {
        ctx1.drawImage(
          margueritetext,
          0,
          0,
          wm,
          hm,
          x,
          y,
          wm / size,
          hm / size
        );
      }
    }
  }

  return canvasherbe;
}

/////////////////////////////////////
///////////Debut chemin//////////////
/////////////////////////////////////

function linspace(startValue, stopValue, cardinality) {
  var arr = [];
  var step = (stopValue - startValue) / (cardinality - 1);
  for (var i = 0; i < cardinality; i++) {
    arr.push(startValue + step * i);
  }
  return arr;
}

function lagrange(x, X, Y) {
  Somme = 0;

  for (let i = 0; i < X.length; i++) {
    lagrangei = 1;
    for (let j = 0; j < X.length; j++) {
      if (i != j) {
        lagrangei = lagrangei * ((x - X[j]) / (X[i] - X[j]));
      }
    }
    Somme = Somme + lagrangei * Y[i];
  }
  return Somme;
}

function buildParametrisationReguliere(nbElem, pas) {
  var T = [];
  var tToEval = [];

  for (let i = 0; i < nbElem; i++) {
    T.push(i);
  }
  var j = 0;
  while (j * pas < nbElem) {
    tToEval.push(j * pas);
    j = j + 1;
  }
  result = [T, tToEval];
  return result;
}

function mintibo(T) {
  mini = 100000;
  for (let i = 0; i < T.length; i++) {
    if (T[i] < mini) {
      mini = T[i];
    }
  }
  return mini;
}

function maxtibo(T) {
  mini = -100000;
  for (let i = 0; i < T.length; i++) {
    if (T[i] > mini) {
      mini = T[i];
    }
  }
  return mini;
}

function buildParametrisationTchebytcheff(nbElem, pas) {
  T = [];
  tToEval1 = [];

  t = 0;

  for (let i = 0; i < nbElem; i++) {
    t = Math.cos(((2 * i + 1) * Math.PI) / (2 * nbElem + 2));
    T.push(t);
  }
  te = mintibo(T);
  tmax = maxtibo(T);
  while (te < tmax) {
    tToEval1.push(te);
    te = te + pas;
  }
  return [T, tToEval1];
}

function computeCheminInterpol(Points) {
  X = [];
  Y = [];
  chemin = [];
  for (let i = 0; i < Points.length; i++) {
    X.push(Points[i][0]);
    Y.push(Points[i][1]);
  }

  var temps = buildParametrisationTchebytcheff(Points.length, 0.01);
  T = temps[0];
  tToEval = temps[1];
  for (let i = 0; i < tToEval.length; i++) {
    xpoint = lagrange(tToEval[i], T, X);
    ypoint = lagrange(tToEval[i], T, Y);
    chemin.push([xpoint, ypoint]);
  }
  return chemin;
}

function computeCheminLigneBrisee(Points) {
  var chemin = [];
  for (let i = 0; i < Points.length - 1; i++) {
    var temps = linspace(0, 1, 20);
    for (let k = 0; k < temps.length; k++) {
      var t = temps[k];
      var x = Math.floor((1 - t) * Points[i][0] + t * Points[i + 1][0]);
      var y = Math.floor((1 - t) * Points[i][1] + t * Points[i + 1][1]);
      chemin.push([x, y]);
    }
  }

  return chemin;
}

/////////////////////////////////////
/////Debut modification masque///////
/////////////////////////////////////

function distancechemin(point, chemin) {
  min = 100000000000000;

  for (let i = 0; i < chemin.length; i++) {
    pc = chemin[i];
    distance = Math.sqrt(
      Math.pow(pc[0] - point[0], 2) + Math.pow(pc[1] - point[1], 2)
    );
    if (distance < min) {
      min = distance;
    }
  }

  return min;
}

function modifierMasque(canvas, chemin) {
  distancemax = 350;
  var ctx = canvas.getContext("2d");
  var w = canvas.width;
  var h = canvas.height;

  var masquedata = ctx.getImageData(0, 0, w, h);

  for (let i = 0; i < w; i++) {
    for (let j = 0; j < h; j++) {
      var point = [i, j];
      n = i * w + j;

      if (
        masquedata.data[4 * n] == 255 &&
        masquedata.data[4 * n + 1] == 0 &&
        masquedata.data[4 * n + 2] == 0
      ) {
        var distance = distancechemin(point, chemin);
        /*
                negatif = Math.random();
                if (negatif < 0.5) {
                    distancemax = distancemax - Math.random() * 100;
    
                } else {
                    distancemax = distancemax + Math.random() * 100;
                }
                */
        if (distance > distancemax) {
          var n = i * w + j;
          masquedata.data[4 * n] = 0;
          masquedata.data[4 * n + 1] = 0;
          masquedata.data[4 * n + 2] = 0;
        }
      }
    }
  }
  ctx.putImageData(masquedata, 0, 0);
  return canvas;
}

function modifierMasque2(canvas, chemin, masque, centres) {
  distancemax = 350;
  var ctx = canvas.getContext("2d");
  var w = canvas.width;
  var h = canvas.height;
  ctx.fillRect(0, 0, w, h);
  canvasdata = ctx.getImageData(0, 0, w, h);
  var ctx2 = masque.getContext("2d");
  var masquedata = ctx2.getImageData(0, 0, w, h);
  var germes = [];
  for (let i = 0; i < centres.length; i++) {
    point = centres[i];
    if (distancechemin(point, chemin) < distancemax) {
      germes.push(point);
    }
  }
  console.log("germes obtenus");

  for (let k = 0; k < germes.length; k++) {
    canvasdata1 = recupPierre(canvasdata, masquedata, germes[k], w, h);
    canvasdata = canvasdata1;
  }
  ctx.putImageData(canvasdata1, 0, 0);
  return canvas;
}

function recupImageData(canvas) {
  var ctx = canvas.getContext("2d");
  var w = canvas.width;
  var h = canvas.height;
  var data = ctx.getImageData(0, 0, w, h);

  return data;
}

function recupPierre(masquedata, copyMasquedata, point, w, h) {
  ipoint = point[0];
  jpoint = point[1];
  n = ipoint * w + jpoint;

  // point centre
  lignehorizontal = [n];
  if (copyMasquedata.data[4 * n] == 255) {
    masquedata.data[4 * n] = 255;
    masquedata.data[4 * n + 1] = 255;
    masquedata.data[4 * n + 2] = 255;
    masquedata.data[4 * n + 3] = 255;
  }

  // ligne horizontale gauche
  ind = n;
  gauche = copyMasquedata.data[4 * (ind - 1)];
  while (gauche == 255 && ind - 1 != 0) {
    masquedata.data[4 * (ind - 1)] = 255;
    masquedata.data[4 * (ind - 1) + 1] = 255;
    masquedata.data[4 * (ind - 1) + 2] = 255;
    masquedata.data[4 * (ind - 1) + 3] = 255;
    ind = ind - 1;
    lignehorizontal.push(ind);
    gauche = copyMasquedata.data[4 * (ind - 1)];
  }

  // ligne horizontale droite
  ind = n;
  droite = copyMasquedata.data[4 * (ind + 1)];
  while (droite == 255 && ind + 1 != 0) {
    masquedata.data[4 * (ind + 1)] = 255;
    masquedata.data[4 * (ind + 1) + 1] = 255;
    masquedata.data[4 * (ind + 1) + 2] = 255;
    masquedata.data[4 * (ind + 1) + 3] = 255;
    ind = ind + 1;
    lignehorizontal.push(ind);
    droite = copyMasquedata.data[4 * (ind + 1)];
  }

  // ligne verticale
  lignevertical = [];

  // ligne verticale bas
  ind = n;
  indMoins1 = ind - w;
  bas = copyMasquedata.data[4 * indMoins1];
  while (bas == 255 && indMoins1 != 0) {
    masquedata.data[4 * indMoins1] = 255;
    masquedata.data[4 * indMoins1 + 1] = 255;
    masquedata.data[4 * indMoins1 + 2] = 255;
    masquedata.data[4 * indMoins1 + 3] = 255;
    //ind = indMoins1;
    lignevertical.push(indMoins1);
    indMoins1 = indMoins1 - w;
    bas = copyMasquedata.data[4 * indMoins1];
  }

  // ligne verticale haut
  ind = n;
  indPlus1 = ind + w;
  gauche = copyMasquedata.data[4 * indPlus1];
  while (gauche == 255 && indPlus1 != 0) {
    masquedata.data[4 * indPlus1] = 255;
    masquedata.data[4 * indPlus1 + 1] = 255;
    masquedata.data[4 * indPlus1 + 2] = 255;
    masquedata.data[4 * indPlus1 + 3] = 255;
    //ind = indPlus1;
    lignevertical.push(indPlus1);
    indPlus1 = indPlus1 + w;
    gauche = copyMasquedata.data[4 * indPlus1];
  }

  // ligne vertical tamp
  ligneverticaltemp = [];
  lignehorizontaltemp = [];

  // recup pixels a partir de la ligne horizontale
  for (let k = 0; k < lignehorizontal.length; k++) {
    ind = lignehorizontal[k];
    indMoins1 = ind - w;
    bas = copyMasquedata.data[4 * indMoins1];
    while (bas == 255 && indMoins1 != 0) {
      masquedata.data[4 * indMoins1] = 255;
      masquedata.data[4 * indMoins1 + 1] = 255;
      masquedata.data[4 * indMoins1 + 2] = 255;
      masquedata.data[4 * indMoins1 + 3] = 255;
      //ind = indMoins1;
      bastemp = indMoins1;
      indMoins1 = indMoins1 - w;
      bas = copyMasquedata.data[4 * indMoins1];
    }
    bastemp = indMoins1;
    ligneverticaltemp.push(bastemp);

    ind = lignehorizontal[k];
    indPlus1 = ind + w;
    haut = copyMasquedata.data[4 * indPlus1];
    while (haut == 255 && indPlus1 != 0) {
      masquedata.data[4 * indPlus1] = 255;
      masquedata.data[4 * indPlus1 + 1] = 255;
      masquedata.data[4 * indPlus1 + 2] = 255;
      masquedata.data[4 * indPlus1 + 3] = 255;
      //ind = indPlus1;
      hauttemp = indPlus1;
      indPlus1 = indPlus1 + w;
      haut = copyMasquedata.data[4 * indPlus1];
    }
    hauttemp = indPlus1;
    ligneverticaltemp.push(hauttemp);
  }

  // recup pixels a partir de la ligne verticale
  for (let k = 0; k < lignevertical.length; k++) {
    ind = lignevertical[k];
    gauche = copyMasquedata.data[4 * (ind - 1)];
    while (gauche == 255 && ind - 1 != 0) {
      masquedata.data[4 * (ind - 1)] = 255;
      masquedata.data[4 * (ind - 1) + 1] = 255;
      masquedata.data[4 * (ind - 1) + 2] = 255;
      masquedata.data[4 * (ind - 1) + 3] = 255;
      ind = ind - 1;
      gauchetemp = ind;
      //lignehorizontal.push(ind)
      gauche = copyMasquedata.data[4 * (ind - 1)];
    }

    lignehorizontaltemp.push(gauchetemp);

    ind = lignevertical[k];
    droite = copyMasquedata.data[4 * (ind + 1)];
    while (droite == 255 && ind + 1 != 0) {
      masquedata.data[4 * (ind + 1)] = 255;
      masquedata.data[4 * (ind + 1) + 1] = 255;
      masquedata.data[4 * (ind + 1) + 2] = 255;
      masquedata.data[4 * (ind + 1) + 3] = 255;
      ind = ind + 1;
      droitetemp = ind;
      //lignehorizontal.push(ind)
      droite = copyMasquedata.data[4 * (ind + 1)];
    }

    lignehorizontaltemp.push(droitetemp);
  }
  /*
    // et zeeeeest reparti horizontal 2e fois
    // recup pixels a partir de la ligne horizontale
    for (let k = 0; k < lignehorizontaltemp.length; k++) {
        ind = lignehorizontaltemp[k];
        indMoins1 = ind - w;
        bas = copyMasquedata.data[4 * indMoins1]
        while (bas == 255 && indMoins1 != 0) {
            masquedata.data[4 * indMoins1] = 255
            masquedata.data[4 * indMoins1 + 1] = 255
            masquedata.data[4 * indMoins1 + 2] = 255
            masquedata.data[4 * indMoins1 + 3] = 255
            //ind = indMoins1;
            indMoins1 = indMoins1 - w;
            bas = copyMasquedata.data[4 * indMoins1]
        }
        
        ind = lignehorizontaltemp[k]
        indPlus1 = ind + w;
        haut = copyMasquedata.data[4 * indPlus1]
        while (haut == 255 && indPlus1 != 0) {
            masquedata.data[4 * indPlus1] = 255
            masquedata.data[4 * indPlus1 + 1] = 255
            masquedata.data[4 * indPlus1 + 2] = 255
            masquedata.data[4 * indPlus1 + 3] = 255
            //ind = indPlus1;
            indPlus1 = indPlus1 + w;
            haut = copyMasquedata.data[4 * indPlus1]
        }

    }
    
    // et zeeeeest reparti vertical 2e fois
    // recup pixels a partir de la ligne verticale
    for (let k = 0; k < ligneverticaltemp.length; k++) {
        ind = ligneverticaltemp[k]
        gauche = copyMasquedata.data[4 * (ind - 1)]
        while ((gauche == 255 && ind - 1 != 0) ) {
            masquedata.data[4 * (ind - 1)] = 255
            masquedata.data[4 * (ind - 1) + 1] = 255
            masquedata.data[4 * (ind - 1) + 2] = 255
            masquedata.data[4 * (ind - 1) + 3] = 255
            ind = ind - 1;
            //lignehorizontal.push(ind)
            gauche = copyMasquedata.data[4 * (ind - 1)]
        }
        ind = ligneverticaltemp[k];
        droite = copyMasquedata.data[4 * (ind + 1)]
        while (droite == 255 && ind + 1 != 0) {
            masquedata.data[4 * (ind + 1)] = 255
            masquedata.data[4 * (ind + 1) + 1] = 255
            masquedata.data[4 * (ind + 1) + 2] = 255
            masquedata.data[4 * (ind + 1) + 3] = 255
            ind = ind + 1;
            //lignehorizontal.push(ind)
            droite = copyMasquedata.data[4 * (ind + 1)]
        }

    }
*/

  return masquedata;
}

function recupPierres(canvas, copyMasquedata) {
  var ctx = canvas.getContext("2d");
  var w = canvas.width;
  var h = canvas.height;
  var masquedata = ctx.getImageData(0, 0, w, h);

  if (masquedata.data.length == copyMasquedata.data.length) {
    for (let i = 0; i < w; i++) {
      for (let j = 0; j < h; j++) {
        var n = i * w + j;

        // cote gauche
        if (n - 1 > 0) {
          if (
            masquedata.data[4 * n] == 255 &&
            masquedata.data[4 * (n - 1)] == 0 &&
            copyMasquedata.data[4 * (n - 1)] == 255
          ) {
            ind = n;
            gauche = copyMasquedata.data[4 * (ind - 1)];
            while (gauche == 255 && ind - 1 != 0) {
              masquedata.data[4 * (ind - 1)] = 255;
              masquedata.data[4 * (ind - 1) + 1] = 255;
              masquedata.data[4 * (ind - 1) + 2] = 255;
              masquedata.data[4 * (ind - 1) + 3] = 255;
              ind = ind - 1;
              gauche = copyMasquedata.data[4 * (ind - 1)];
            }
          }
        }

        // cote droit
        if (n - 1 > 0) {
          if (
            masquedata.data[4 * n] == 255 &&
            masquedata.data[4 * (n + 1)] == 0 &&
            copyMasquedata.data[4 * (n + 1)] == 255
          ) {
            ind = n;
            gauche = copyMasquedata.data[4 * (ind + 1)];
            while (gauche == 255 && ind + 1 != 0) {
              masquedata.data[4 * (ind + 1)] = 255;
              masquedata.data[4 * (ind + 1) - 1] = 255;
              masquedata.data[4 * (ind + 1) - 2] = 255;
              masquedata.data[4 * (ind + 1) - 3] = 255;
              ind = ind + 1;
              gauche = copyMasquedata.data[4 * (ind + 1)];
            }
          }
        }
      }
    }

    for (let i = 0; i < w; i++) {
      for (let j = 0; j < h; j++) {
        var n = i * w + j;
        var nMoins1 = (i - 1) * w + j;
        var nPlus1 = (i + 1) * w + j;

        // en haut
        if (nMoins1 >= 4) {
          if (
            masquedata.data[4 * n] == 255 &&
            masquedata.data[4 * nMoins1] == 0 &&
            copyMasquedata.data[4 * nMoins1] == 255
          ) {
            ind = n;
            indMoins1 = n - w;
            gauche = copyMasquedata.data[4 * indMoins1];
            while (gauche == 255 && indMoins1 != 0) {
              masquedata.data[4 * indMoins1] = 255;
              masquedata.data[4 * indMoins1 - 1] = 255;
              masquedata.data[4 * indMoins1 - 2] = 255;
              masquedata.data[4 * indMoins1 - 3] = 255;
              ind = indMoins1;
              indMoins1 = indMoins1 - w;
              gauche = copyMasquedata.data[4 * indMoins1];
            }
          }
        }

        // en bas
        if (nPlus1 <= masquedata.data.length) {
          if (
            masquedata.data[4 * n] == 255 &&
            masquedata.data[4 * nPlus1] == 0 &&
            copyMasquedata.data[4 * nPlus1] == 255
          ) {
            ind = n;
            indPlus1 = n + w;
            gauche = copyMasquedata.data[4 * indPlus1];
            while (gauche == 255 && indPlus1 != 0) {
              masquedata.data[4 * indPlus1] = 255;
              masquedata.data[4 * indPlus1 + 1] = 255;
              masquedata.data[4 * indPlus1 + 2] = 255;
              masquedata.data[4 * indPlus1 + 3] = 255;
              ind = indPlus1;
              indPlus1 = indPlus1 + w;
              gauche = copyMasquedata.data[4 * indPlus1];
            }
          }
        }
      }
    }

    /*
        if (masquedata.data[i] != copyMasquedata.data[i]) {
            masquedata.data[i] = 255
        }*/
  }

  ctx.putImageData(masquedata, 0, 0);

  return canvas;
}

function transformCanvastoThreeCoordonates(x, z) {
  var newx = z / 512 - 5;
  var newz = x / 512 - 5;
  var newy = 0.1;
  coordonnees = [newx, newy, newz];
  return coordonnees;
}

function transformThreeCoordonatestoCanvas(x, z) {
  var newx = (z + 5) * 512;
  var newz = (x + 5) * 512;
  coordonnees = [newx, newz];
  return coordonnees;
}

function dupliquer(centres, Xrepeat, Yrepeat, w, h) {
  T = [];

  for (let k = 0; k < centres.length; k++) {
    var x = centresTexturePaveJoint[k][0];
    var y = centresTexturePaveJoint[k][1];

    for (let i = 0; i < Xrepeat; i++) {
      for (let j = 0; j < Yrepeat; j++) {
        var xnouveau = x + i * w;
        var ynouveau = y + j * h;
        T.push([xnouveau, ynouveau]);
      }
    }
  }

  return T;
}

// Fonction d'initialisation des textures
function init_textures() {
  ////////////////////////////////////// HERBES ////////////////////
  // Get a reference to the image you want the pixels of and its dimensions
  herbetext = document.getElementById("herbetext");

  ///////////////////////////////////////////////////////////////////////////////
  // Pour n'afficher que les edges
  wireframe_mode = false;

  var canvasherbe = createTextureHerbe(10, 10);
  var textureGrass = defineTextureCanvas(canvasherbe, 0, 0, false);
  textureGrass.minFilter = THREE.LinearFilter;

  var textureGrassBasique = defineTexture(
    "graphics/freeTexture2.png",
    10,
    10,
    true
  );

  materialGrassBasique = new THREE.MeshBasicMaterial({
    map: textureGrassBasique,
    side: THREE.DoubleSide,
    wireframe: wireframe_mode,
    shininess: 0,
  });
  materialGrass = new THREE.MeshBasicMaterial({
    map: textureGrass,
    side: THREE.DoubleSide,
    wireframe: wireframe_mode,
  });

  //console.log(materialGrassBasique)

  textures = defineTexture("graphics/textures.png", 1, 1);
  textures.anisotropy = 16;

  textureMask = defineTexture("graphics/masque_freeTexture5.png", 10, 10, true);

  ////////////////////////////////////////////////////////TEXTURE/////////////////////////////

  var canvas1 = createCanvasforTextureRepeat("texture", 10, 10);

  var textureRock5bis = defineTextureCanvas(canvas1, 0, 0, false);
  textureRock5bis.minFilter = THREE.LinearFilter;

  ///////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////MASQUE////////////////////

  var canvas = createCanvasforTextureRepeat("masque", 10, 10);

  var myImage1 = document.getElementById("masque");

  var w1 = myImage1.width,
    h1 = myImage1.height;

  var canvas2 = document.createElement("canvas");

  // Size the canvas to the element
  canvas2.width = canvas1.width;
  canvas2.height = canvas1.height;

  Points = [
    [0, 0],
    [500, 1000],
    [2000, 3000],
    [4000, 2000],
    [5000, 3000],
  ];
  var chemin = computeCheminInterpol(Points);

  var centres = dupliquer(centresTexturePaveJoint, 10, 10, w1, h1);
  console.log("modifierMasque2");
  canvas2 = modifierMasque2(canvas2, chemin, canvas, centres);

  /*
    canvas = createCanvasforTextureRepeat('masque', 10, 10);

    var copyMasquedata = recupImageData(canvas);

    Points = [[0, 0], [500, 1000], [2000, 3000], [4000, 2000], [5000, 3000]];
    var chemin = computeCheminInterpol(Points);
    modifierMasque(canvas, chemin);

    recupPierres(canvas, copyMasquedata);
    */

  var texturemasque = defineTextureCanvas(canvas2, 0, 0, true);
  texturemasque.minFilter = THREE.LinearFilter;
  //////////////////////////////////////////////////////////////////////////////////////////
  materialRock5 = new THREE.MeshBasicMaterial({
    alphaMap: texturemasque,
    alphaTest: 0.5,
    map: textureRock5bis,
    side: THREE.DoubleSide,
    wireframe: wireframe_mode,
  });
}

// Fonction d'initialisation principale
function init() {
  document.addEventListener(
    "contextmenu",
    function (event) {
      event.preventDefault();
    },
    false
  );

  space = false;

  // Déplacement dans la scène avec Z Q S D
  mouvement = { haut: false, bas: false, droite: false, gauche: false };
  mouvementcube = { haut: false, bas: false, droite: false, gauche: false };

  document.addEventListener("keydown", function (event) {
    if (event.keyCode == 68) {
      mouvement.haut = true;
    } else if (event.keyCode == 81) {
      mouvement.bas = true;
    } else if (event.keyCode == 90) {
      mouvement.droite = true;
    } else if (event.keyCode == 83) {
      mouvement.gauche = true;
    } else if (event.keyCode == 38) {
      mouvementcube.gauche = true;
    } else if (event.keyCode == 40) {
      mouvementcube.droite = true;
    } else if (event.keyCode == 37) {
      mouvementcube.haut = true;
    } else if (event.keyCode == 39) {
      mouvementcube.bas = true;
    } else if (event.keyCode == 32) {
      space = true;
    } else if (event.keyCode == 16) {
      selectionPoints = true;
    } else if ((event.keyCode = 13)) {
      rendre = true;
    }
  });

  document.addEventListener("keyup", function (event) {
    if (event.keyCode == 68) {
      mouvement.haut = false;
    } else if (event.keyCode == 81) {
      mouvement.bas = false;
    } else if (event.keyCode == 90) {
      mouvement.droite = false;
    } else if (event.keyCode == 83) {
      mouvement.gauche = false;
    } else if (event.keyCode == 38) {
      mouvementcube.gauche = false;
    } else if (event.keyCode == 40) {
      mouvementcube.droite = false;
    } else if (event.keyCode == 37) {
      mouvementcube.haut = false;
    } else if (event.keyCode == 39) {
      mouvementcube.bas = false;
    }
  });

  selectionPoints = false;
  rendre = false;
  dejacube = false;
  compteur = 0;

  mapW = 10;
  mapH = 10;

  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    100
  );

  renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Ajout d'une source de lumière
  luminosite = 1; // entre 0 et 1
  ambiantLight = new THREE.AmbientLight(0xcccccc, luminosite);
  scene.add(ambiantLight);

  // Ajout des contrôles à la souris
  controls = new THREE.OrbitControls(camera, renderer.domElement);

  //controls.update() doit être appelé chaque fois que la position de la caméra est modifiée manuellement
  camera.position.set(0, 4, 0);
  controls.update();

  // Création des deux plans
  epsilon = 0.001;

  meshGrass = definePlane(materialGrass, 0, 0, 0, mapW, mapH, 10, 10);
  meshGrass.name = "herbe";
  scene.add(meshGrass);

  meshFloor = definePlane(materialRock5, 0, epsilon, 0, mapW, mapH, 10, 10);
  meshFloor.name = "floor";
  scene.add(meshFloor);
  pointsClick = [];
  for (let i = 0; i < chemin.length; i++) {
    x = chemin[i][0];
    z = chemin[i][1];
    newcoordinates = transformCanvastoThreeCoordonates(x, z);
    pointsClick.push(
      new THREE.Vector3(newcoordinates[0], newcoordinates[1], newcoordinates[2])
    );
  }

  geometryClick = new THREE.Geometry().setFromPoints(pointsClick);
  materialClick = new THREE.LineBasicMaterial({ color: 0x0000ff });

  lineClick = new THREE.Line(geometryClick, materialClick);
  lineClick.name = "line";
  scene.add(lineClick);

  /*
    textureFleur = defineTexture("graphics/fleur.png", 10, 10, true)
    //materialGrass = new THREE.MeshBasicMaterial({ map: textureFleur, side: THREE.DoubleSide, wireframe: wireframe_mode, shininess: 0 });

    
    meshFleur = definePlane(textureFleur, 0, epsilon+0.1, 0, 1, 1, 1, 1)
    scene.add(meshFleur)

*/
}
/*
function afficherFleur(canvas) {

    ctx = canvas.getContext('2d')
    img = new_image("graphics/Texture11/fleur.png");
    img.onload = function () {
        console.log("chargé")
        w1 = img.width;
        h1 = img.width
        ctx.drawImage(img, 20, 20)
    }
    return canvas



}*/

// Boucle principale qui se rappelle à l'infini
function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
  if (mouvement.bas) {
    scene.position.x += 0.1;
  } else if (mouvement.haut) {
    scene.position.x -= 0.1;
  } else if (mouvement.droite) {
    scene.position.z += 0.1;
  } else if (mouvement.gauche) {
    scene.position.z -= 0.1;
  } else if (mouvementcube.haut) {
    cube.position.x -= 0.03;
  } else if (mouvementcube.bas) {
    cube.position.x += 0.03;
  } else if (mouvementcube.droite) {
    cube.position.z += 0.03;
  } else if (mouvementcube.gauche) {
    cube.position.z -= 0.03;
  } else if (space) {
    xenter = cube.position.x;
    zenter = cube.position.z;
    coordonnespoint = transformThreeCoordonatestoCanvas(xenter, zenter);
    console.log(coordonnespoint);
    Points.push(coordonnespoint);

    geometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
    material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    cubes.push(new THREE.Mesh(geometry, material));
    cubes[compteur].name = "cube" + compteur;
    cubes[compteur].position.x = xenter;
    cubes[compteur].position.z = zenter;
    scene.add(cubes[compteur]);
    compteur = compteur + 1;

    space = false;
  } else if (selectionPoints) {
    for (let i = 0; i < compteur; i++) {
      var selectedObject = scene.getObjectByName("cube" + i);
      scene.remove(selectedObject);
    }

    cubes = [];
    compteur = 0;
    var selectedObject = scene.getObjectByName("line");
    scene.remove(selectedObject);

    var selectedObject = scene.getObjectByName("floor");
    scene.remove(selectedObject);
    if (!dejacube) {
      geometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
      material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
      cube = new THREE.Mesh(geometry, material);
      cube.name = "cube";
      scene.add(cube);
    }

    console.log("construction de chemin");
    dejacube = true;
    selectionPoints = false;
    Points = [];
  } else if (rendre) {
    ////////////////////////////////////////////////////////TEXTURE/////////////////////////////

    var canvas1 = createCanvasforTextureRepeat("texture", 10, 10);
    var ctx = canvas1.getContext("2d");

    var textureRock5bis = defineTextureCanvas(canvas1, 0, 0, false);
    textureRock5bis.minFilter = THREE.LinearFilter;

    ///////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////MASQUE////////////////////

    var canvas = createCanvasforTextureRepeat("masque", 10, 10);

    var myImage1 = document.getElementById("masque");

    var w1 = myImage1.width,
      h1 = myImage1.height;

    var canvas2 = document.createElement("canvas");

    // Size the canvas to the element
    canvas2.width = canvas1.width;
    canvas2.height = canvas1.height;

    var chemin = computeCheminInterpol(Points);

    var centres = dupliquer(centresTexturePaveJoint, 10, 10, w1, h1);
    console.log("modifierMasque2");
    canvas2 = modifierMasque2(canvas2, chemin, canvas, centres);
    //canvas2 = afficherFleur(canvas2);
    var texturemasque = defineTextureCanvas(canvas2, 0, 0, true);
    texturemasque.minFilter = THREE.LinearFilter;
    //////////////////////////////////////////////////////////////////////////////////////////
    materialRock5 = new THREE.MeshBasicMaterial({
      alphaMap: texturemasque,
      alphaTest: 0.5,
      map: textureRock5bis,
      side: THREE.DoubleSide,
      wireframe: wireframe_mode,
      shininess: 0,
    });
    meshFloor = definePlane(materialRock5, 0, epsilon, 0, mapW, mapH, 10, 10);
    meshFloor.name = "floor";
    scene.add(meshFloor);
    pointsClick = [];
    for (let i = 0; i < chemin.length; i++) {
      x = chemin[i][0];
      z = chemin[i][1];
      newcoordinates = transformCanvastoThreeCoordonates(x, z);
      pointsClick.push(
        new THREE.Vector3(
          newcoordinates[0],
          newcoordinates[1],
          newcoordinates[2]
        )
      );
    }

    geometryClick = new THREE.Geometry().setFromPoints(pointsClick);
    materialClick = new THREE.LineBasicMaterial({ color: 0x0000ff });

    lineClick = new THREE.Line(geometryClick, materialClick);
    lineClick.name = "line";
    scene.add(lineClick);
    rendre = false;
    var selectedObject = scene.getObjectByName("cube");
    scene.remove(selectedObject);
    dejacube = false;

    for (let i = 0; i < compteur; i++) {
      var selectedObject = scene.getObjectByName("cube" + i);
      scene.remove(selectedObject);
    }
  }
}

// Assigner des élévations aléatoires aux vertices des maillages plans
function randomize_elevation(value = 0.4, offset = 0) {
  for (let i = 0; i < meshFloor.geometry.vertices.length; i++) {
    let random_value = Math.random();
    meshFloor.geometry.vertices[i].z = random_value * value + offset + epsilon;
    meshGrass.geometry.vertices[i].z = random_value * value + offset;
  }

  meshFloor.geometry.verticesNeedUpdate = true;
  meshGrass.geometry.verticesNeedUpdate = true;
  meshFloor.geometry.facesNeedUpdate = true;
  meshGrass.geometry.facesNeedUpdate = true;
  meshGrass.geometry.elementsNeedUpdate = true;
  meshFloor.geometry.elementsNeedUpdate = true;
}

function applyLoop(iteration) {
  meshFloor.geometry.uvsNeedUpdate = true;
  meshGrass.geometry.uvsNeedUpdate = true;

  meshFloor.geometry.morphTargetsNeedUpdate = true;

  meshFloor.geometry.normalsNeedUpdate = true;
  meshFloor.geometry.colorsNeedUpdate = true;
  meshFloor.geometry.tangentsNeedUpdate = true;
  meshGrass.geometry.morphTargetsNeedUpdate = true;

  meshGrass.geometry.normalsNeedUpdate = true;
  meshGrass.geometry.colorsNeedUpdate = true;
  meshGrass.geometry.tangentsNeedUpdate = true;
  for (let j = 0; j < iteration; j++) {
    let result = loop(meshFloor.geometry.vertices, meshFloor.geometry.faces);
    meshFloor.geometry.vertices = result[0];
    meshFloor.geometry.faces = result[1];

    let result1 = loop(meshGrass.geometry.vertices, meshGrass.geometry.faces);
    meshGrass.geometry.vertices = result1[0];
    meshGrass.geometry.faces = result1[1];
  }

  var geometryf = new THREE.Geometry();

  for (let i = 0; i < meshFloor.geometry.vertices.length; i++) {
    geometryf.vertices.push(meshFloor.geometry.vertices[i]);
  }

  for (let i = 0; i < meshFloor.geometry.faces.length; i++) {
    geometryf.faces.push(meshFloor.geometry.faces[i]);
  }

  var geometryg = new THREE.Geometry();

  for (let i = 0; i < meshGrass.geometry.vertices.length; i++) {
    geometryg.vertices.push(meshGrass.geometry.vertices[i]);
  }

  for (let i = 0; i < meshGrass.geometry.faces.length; i++) {
    geometryg.faces.push(meshGrass.geometry.faces[i]);
  }

  geometryf.computeFaceNormals();
  geometryg.computeFaceNormals();

  //ThreeUvMapper.assignUVs(geometryf);
  //ThreeUvMapper.assignUVs(geometryg);

  console.log("new");
  var selectedObject = scene.getObjectByName("herbe");
  scene.remove(selectedObject);

  var selectedObject = scene.getObjectByName("floor");
  scene.remove(selectedObject);

  var meshFloor1 = new THREE.Mesh(geometryf, materialRock5);
  meshFloor1.name = "floor1";
  scene.add(meshFloor1);

  var meshGrass1 = new THREE.Mesh(geometryg, materialGrass);
  meshGrass1.name = "grass1";
  scene.add(meshGrass1);
}

function loop(origVert, origMesh) {
  const geometry = new THREE.Geometry();
  destVert = geometry.vertices;
  destMesh = geometry.faces;
  for (let i = 0; i < origVert.length; i++) {
    destVert.push(origVert[i]);
  }

  let newVertices = [];

  for (let j = 0; j < origMesh.length; j++) {
    let v1 = origMesh[j].a;
    let v2 = origMesh[j].b;
    let v3 = origMesh[j].c;

    let e1 = [v1, v2];
    let e2 = [v2, v3];
    let e3 = [v3, v1];

    let result1 = getNewVertex(e1, destVert, origMesh, newVertices);
    let midpointa = result1[0];
    destVert = result1[1];
    newVertices = result1[2];

    let result2 = getNewVertex(e2, destVert, origMesh, newVertices);
    let midpointb = result2[0];
    destVert = result2[1];
    newVertices = result2[2];

    let result3 = getNewVertex(e3, destVert, origMesh, newVertices);
    let midpointc = result3[0];
    destVert = result3[1];
    newVertices = result3[2];

    let v1ac = new THREE.Face3(v1, midpointa, midpointc);
    let abc = new THREE.Face3(midpointa, midpointb, midpointc);
    let av2b = new THREE.Face3(midpointa, v2, midpointb);
    let cbv3 = new THREE.Face3(midpointc, midpointb, v3);

    destMesh.push(v1ac);
    destMesh.push(abc);
    destMesh.push(cbv3);
    destMesh.push(av2b);
  }

  let occurences = [];
  let tmp = [];
  for (let j = 0; j < origVert.length; j++) {
    occurences.push(0);
  }
  for (let j = 0; j < origVert.length; j++) {
    tmp.push([0, 0, 0]);
  }

  for (let i = 0; i < origMesh.length; i++) {
    let v1 = origMesh[i].a;
    let v2 = origMesh[i].b;
    let v3 = origMesh[i].c;

    occurences[v1] = occurences[v1] + 1;
    occurences[v2] = occurences[v2] + 1;
    occurences[v3] = occurences[v3] + 1;

    tmp[v1][0] =
      tmp[v1][0] +
      (5 / 8) * origVert[v1].x +
      (3 / 16) * (origVert[v2].x + origVert[v3].x);
    tmp[v1][1] =
      tmp[v1][1] +
      (5 / 8) * origVert[v1].y +
      (3 / 16) * (origVert[v2].y + origVert[v3].y);
    tmp[v1][2] =
      tmp[v1][2] +
      (5 / 8) * origVert[v1].z +
      (3 / 16) * (origVert[v2].z + origVert[v3].z);

    tmp[v2][0] =
      tmp[v2][0] +
      (5 / 8) * origVert[v2].x +
      (3 / 16) * (origVert[v1].x + origVert[v3].x);
    tmp[v2][1] =
      tmp[v2][1] +
      (5 / 8) * origVert[v2].y +
      (3 / 16) * (origVert[v1].y + origVert[v3].y);
    tmp[v2][2] =
      tmp[v2][2] +
      (5 / 8) * origVert[v2].z +
      (3 / 16) * (origVert[v1].z + origVert[v3].z);

    tmp[v3][0] =
      tmp[v3][0] +
      (5 / 8) * origVert[v3].x +
      (3 / 16) * (origVert[v2].x + origVert[v1].x);
    tmp[v3][1] =
      tmp[v3][1] +
      (5 / 8) * origVert[v3].y +
      (3 / 16) * (origVert[v2].y + origVert[v1].y);
    tmp[v3][2] =
      tmp[v3][2] +
      (5 / 8) * origVert[v3].z +
      (3 / 16) * (origVert[v2].z + origVert[v1].z);
  }

  for (let i = 0; i < origVert.length; i++) {
    if (occurences[i] != 0) {
      destVert[i] = new THREE.Vector3(
        tmp[i][0] / occurences[i],
        tmp[i][2] / occurences[i],
        tmp[i][1] / occurences[i]
      );
    }
  }
  /*
  destNorm.length = 0;
  for (let j = 0; j < destVert.length; j++) {
    destNorm.push([0, 0, 0]);
  }

  for (let i = 0; i < destMesh.length; i++) {
    let t = new THREE.Face3(destMesh[i].a, destMesh[i].b, destMesh[i].c);
    let v1 = destVert[t.a];
    let v2 = destVert[t.b];
    let v3 = destVert[t.c];

    let norm = computeNormal(v1, v2, v3);
    destNorm[t.a] = destNorm[t.a] + norm;
    destNorm[t.b] = destNorm[t.b] + norm;
    destNorm[t.c] = destNorm[t.c] + norm;
  }

  for (let i = 0; i < destNorm.length; i++) {
    destNorm[i] = normalize(destNorm[i]);
  }
  */
  return [destVert, destMesh];
}

function getNewVertex(e, vertlist, mesh, newVertlist) {
  let i;
  if (!contientEdge(newVertlist, e)) {
    let newindex = vertlist.length;

    newVertlist.push([e, newindex]);

    let nvert = [0, 0, 0];
    let oppV1;
    let oppV2;

    let result = isBoundaryEdge(e, mesh);
    oppV1 = result[1];
    oppV2 = result[2];
    if (!result[0]) {
      let V1 = e[0];
      let V2 = e[1];
      let v1 = vertlist[V1];
      let v2 = vertlist[V2];

      let oppv1 = vertlist[oppV1];
      let oppv2 = vertlist[oppV2];

      nvert[0] = (v1.x + v2.x) * (3 / 8) + (1 / 8) * (oppv1.x + oppv2.x);
      nvert[1] = (v1.y + v2.y) * (3 / 8) + (1 / 8) * (oppv1.y + oppv2.y);
      nvert[2] = (v1.z + v2.z) * (3 / 8) + (1 / 8) * (oppv1.z + oppv2.z);
    } else {
      let V1 = e[0];
      let V2 = e[1];

      let v1 = vertlist[V1];
      let v2 = vertlist[V2];
      nvert[0] = (1 / 2) * (v1.x + v2.x);
      nvert[1] = (1 / 2) * (v1.y + v2.y);
      nvert[2] = (1 / 2) * (v1.z + v2.z);
    }
    vertlist.push(new THREE.Vector3(nvert[0], nvert[2], nvert[1]));
    return [newindex, vertlist, newVertlist];
  } else {
    i = getIndex(newVertlist, e);
    return [i, vertlist, newVertlist];
  }
  return [0, vertlist, newVertlist];
}

function getIndex(newVertlist, e) {
  for (let i = 0; i < newVertlist.length; i++) {
    let ec = newVertlist[i][0];
    if ((ec[0] == e[0] && ec[1] == e[1]) | (ec[1] == e[0] && ec[0] == e[1])) {
      return newVertlist[i][1];
    }
  }
  return -1;
}

function containsEdge(face, e) {
  let v1 = face.a;
  let v2 = face.b;
  let v3 = face.c;
  let oppositeVertex;

  if ((v1 == e[0] && v2 == e[1]) | (v1 == e[1] && v2 == e[0])) {
    oppositeVertex = v3;
    return [true, oppositeVertex];
  } else if ((v3 == e[0] && v2 == e[1]) | (v3 == e[1] && v2 == e[0])) {
    oppositeVertex = v1;
    return [true, oppositeVertex];
  } else if ((v1 == e[0] && v3 == e[1]) | (v1 == e[1] && v3 == e[0])) {
    oppositeVertex = v2;
    return [true, oppositeVertex];
  } else {
    return false;
  }
}

function isBoundaryEdge(e, mesh) {
  let foundFirst = false;
  let foundSecond = false;
  let oppV1;
  let oppV2;
  for (let i = 0; i < mesh.length && !(foundFirst && foundSecond); i++) {
    if (!foundFirst) {
      let result = containsEdge(mesh[i], e);
      foundFirst = result[0];
      oppV1 = result[1];
    } else {
      let result = containsEdge(mesh[i], e);
      foundSecond = result[0];
      oppV2 = result[1];
    }
  }
  return [foundFirst && !foundSecond, oppV1, oppV2];
}

function contientEdge(newVertlist, e) {
  for (let i = 0; i < newVertlist.length; i++) {
    if (
      (newVertlist[i][1][0] == e[0] && newVertlist[i][1] == e[1]) |
      (newVertlist[i][1] == e[0] && newVertlist[i][0] == e[1])
    ) {
      return true;
    }
  }
  return false;
}
function normalize(vec) {
  let norm = Math.sqrt(vec[0] * vec[0] + vec[1] ** 2 + vec[2] ** 2);
  let vecret = [0, 0, 0];
  vecret[0] = vec[0] / norm;
  vecret[1] = vec[1] / norm;
  vecret[2] = vec[2] / norm;
  return vecret;
}

function computeNormal(v1, v2, v3) {
  let diff1 = [0, 0, 0];
  diff1[0] = v2[0] - v1[0];
  diff1[1] = v2[1] - v1[1];
  diff1[2] = v2[2] - v1[2];

  let diff2 = [0, 0, 0];
  diff2[0] = v3[0] - v1[0];
  diff2[1] = v3[1] - v1[1];
  diff2[2] = v3[2] - v1[2];

  let norm = [0, 0, 0];
  norm[0] = diff1[1] * diff2[2] - diff1[2] * diff2[1];
  norm[1] = diff1[2] * diff2[0] - diff1[0] * diff2[2];
  norm[2] = diff1[0] * diff2[1] - diff1[1] * diff2[0];
  return norm;
}

// Récupérer l'élévation correspondant à une position au sol donnée
function zPos(x, y) {
  let caseX = Math.floor(x);
  let caseY = Math.floor(y);
  let u = (x + 100) % 1;
  let v = (y + 100) % 1;

  let indexFace = 200 * (caseZ + 50) + 2 * (caseX + 50) + (u + v > 1);
  if (meshFloor.geometry.faces[indexFace] === undefined) {
    return 0;
  }
  let pt1 = meshFloor.geometry.vertices[meshFloor.geometry.faces[indexFace].a];
  let pt2 = meshFloor.geometry.vertices[meshFloor.geometry.faces[indexFace].b];
  let pt3 = meshFloor.geometry.vertices[meshFloor.geometry.faces[indexFace].c];

  if (u + v < 1) {
    return pt1.z + (pt3.z - pt1.z) * u + (pt2.z - pt1.z) * v;
  } else {
    return pt1.z + pt3.z - pt2.z + (pt2.z - pt1.z) * u + (pt2.z - pt3.z) * v;
  }
}
